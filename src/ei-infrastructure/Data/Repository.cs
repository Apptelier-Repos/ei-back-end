using System.Data;
using System.Threading.Tasks;
using ei_core.Entities.UserAccountAggregate;
using ei_core.Interfaces;
using ei_infrastructure.Data.Queries;

namespace ei_infrastructure.Data
{
    public class Repository : IRepository
    {
        // TODO: CatalogContext below not used, check.
        protected readonly CatalogContext DbContext;
        private readonly IDbConnection _connection;

        public Repository(CatalogContext dbContext, IDbConnection connection)
        {
            DbContext = dbContext;
            _connection = connection;
        }

        public async Task<UserAccount> FindUserAccountByIdAsync(int id)
        {
            var userAccountDto = await new QueriesService(_connection).GetUserAccountByIdAsync(id);
            var userAccountRootAggregate = new UserAccount(userAccountDto.Id, userAccountDto.CreationDate, userAccountDto.Username, userAccountDto.Password);

            //return userAccountRootAggregate;

            // TODO:
            // new is glue, therefore Autofac should be used intead here. This assembly should be registered and located by Autofac.
            // Organize the DTO namespaces, classes, interfaces in both core and infra.
            // This Repository should:
            // * Collect the DTOs from the queries in QueriesService and then use those DTOs to assemble the DDDs root aggregates (e.g. UserAccount root aggregate) that will be returned back.
            // * Receive the IDBConnection from consuming projects? Need to think how Autofac will affect this.
            // QueriesService should:
            // * For queries, it should return DTOs filled by Dapper using queries generated by SQL Kata.

            throw new System.NotImplementedException();
        }
    }
}